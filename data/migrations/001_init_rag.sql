-- Enable pgvector extension for vector operations
CREATE EXTENSION IF NOT EXISTS vector;

-- Drop existing tables if they exist (for clean reinstall)
DROP TABLE IF EXISTS memory_edge CASCADE;
DROP TABLE IF EXISTS memory_chunk CASCADE;
DROP TABLE IF EXISTS memory CASCADE;

-- Main memory table with full text and metadata (no embedding here)
CREATE TABLE memory (
    id          SERIAL PRIMARY KEY,
    text        TEXT NOT NULL,  -- Full text content
    
    -- Optional metadata fields
    category    VARCHAR(100),
    source      TEXT,
    
    -- Timestamps
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    updated_at  TIMESTAMPTZ
);

-- Indexes for memory table
CREATE INDEX idx_memory_id ON memory (id);
CREATE INDEX idx_memory_created_at ON memory (created_at DESC);
CREATE INDEX idx_memory_category ON memory (category) WHERE category IS NOT NULL;

-- Memory chunks table - stores text chunks with embeddings
CREATE TABLE memory_chunk (
    id          SERIAL PRIMARY KEY,
    memory_id   INTEGER NOT NULL,
    chunk_text  TEXT NOT NULL,
    chunk_index INTEGER NOT NULL,  -- Order of chunk within memory (0-based)
    embedding   VECTOR(1536),  -- text-embedding-3-small dimension
    
    -- Timestamps
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT fk_memory_chunk_memory
        FOREIGN KEY (memory_id) REFERENCES memory (id) ON DELETE CASCADE,
    CONSTRAINT uq_memory_chunk_index UNIQUE (memory_id, chunk_index)
);

-- Indexes for memory_chunk table
CREATE INDEX idx_memory_chunk_memory_id ON memory_chunk (memory_id);
CREATE INDEX idx_memory_chunk_index ON memory_chunk (memory_id, chunk_index);

-- IVFFlat index for fast cosine similarity search on chunks
-- Note: This index should be created AFTER inserting data for better performance
-- For empty tables, you may want to create it later
CREATE INDEX idx_memory_chunk_embedding_cosine
ON memory_chunk
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Alternative: L2 distance index (uncomment if needed)
-- CREATE INDEX idx_memory_chunk_embedding_l2
-- ON memory_chunk
-- USING ivfflat (embedding vector_l2_ops)
-- WITH (lists = 100);

-- Memory edges table for similarity relationships
CREATE TABLE memory_edge (
    source_id   INTEGER NOT NULL,
    target_id   INTEGER NOT NULL,
    weight      DOUBLE PRECISION NOT NULL CHECK (weight >= 0.0 AND weight <= 1.0),
    created_at  TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT pk_memory_edge PRIMARY KEY (source_id, target_id),
    CONSTRAINT fk_memory_edge_source
        FOREIGN KEY (source_id) REFERENCES memory (id) ON DELETE CASCADE,
    CONSTRAINT fk_memory_edge_target
        FOREIGN KEY (target_id) REFERENCES memory (id) ON DELETE CASCADE,
    CONSTRAINT chk_no_self_loops CHECK (source_id != target_id)
);

-- Indexes for memory_edge table
CREATE INDEX idx_memory_edge_source ON memory_edge (source_id);
CREATE INDEX idx_memory_edge_target ON memory_edge (target_id);
CREATE INDEX idx_memory_edge_weight ON memory_edge (weight DESC);

-- Composite index for finding edges by source and weight
CREATE INDEX idx_memory_edge_source_weight ON memory_edge (source_id, weight DESC);

-- Comments for documentation
COMMENT ON TABLE memory IS 'Stores full text memories without embeddings';
COMMENT ON TABLE memory_chunk IS 'Stores text chunks with vector embeddings for semantic search';
COMMENT ON TABLE memory_edge IS 'Stores similarity relationships between memories as a graph';
COMMENT ON COLUMN memory_chunk.embedding IS 'Vector embedding generated by OpenAI text-embedding-3-small (1536 dimensions)';
COMMENT ON COLUMN memory_chunk.chunk_index IS 'Zero-based index indicating chunk order within the memory';
COMMENT ON COLUMN memory_edge.weight IS 'Similarity score between 0.0 and 1.0';

-- Optional: Create a view for easy querying of connected memories
CREATE OR REPLACE VIEW memory_connections AS
SELECT 
    m1.id AS source_id,
    m1.text AS source_text,
    m1.category AS source_category,
    m2.id AS target_id,
    m2.text AS target_text,
    m2.category AS target_category,
    me.weight AS similarity_score
FROM memory_edge me
JOIN memory m1 ON me.source_id = m1.id
JOIN memory m2 ON me.target_id = m2.id
ORDER BY me.weight DESC;

COMMENT ON VIEW memory_connections IS 'Convenient view showing memory connections with full text';

-- Optional: Create a view for memory chunks with their parent memory info
CREATE OR REPLACE VIEW memory_chunk_details AS
SELECT 
    mc.id AS chunk_id,
    mc.memory_id,
    mc.chunk_index,
    mc.chunk_text,
    m.text AS full_memory_text,
    m.category,
    m.source,
    mc.created_at AS chunk_created_at,
    m.created_at AS memory_created_at
FROM memory_chunk mc
JOIN memory m ON mc.memory_id = m.id
ORDER BY mc.memory_id, mc.chunk_index;

COMMENT ON VIEW memory_chunk_details IS 'Convenient view showing chunks with their parent memory information';
