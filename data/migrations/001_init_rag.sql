-- Enable pgvector extension for vector operations
CREATE EXTENSION IF NOT EXISTS vector;

-- Drop existing tables if they exist (for clean reinstall)
DROP TABLE IF EXISTS memory_edge CASCADE;
DROP TABLE IF EXISTS memory CASCADE;

-- Main memory table with embeddings and metadata
CREATE TABLE memory (
    id          SERIAL PRIMARY KEY,
    text        TEXT NOT NULL,
    embedding   VECTOR(1536), -- text-embedding-3-small dimension
    
    -- Optional metadata fields
    category    VARCHAR(100),
    source      VARCHAR(255),
    
    -- Timestamps
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    updated_at  TIMESTAMPTZ
);

-- Indexes for memory table
CREATE INDEX idx_memory_id ON memory (id);
CREATE INDEX idx_memory_created_at ON memory (created_at DESC);
CREATE INDEX idx_memory_category ON memory (category) WHERE category IS NOT NULL;

-- IVFFlat index for fast cosine similarity search
-- Note: This index should be created AFTER inserting data for better performance
-- For empty tables, you may want to create it later
CREATE INDEX idx_memory_embedding_cosine
ON memory
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Alternative: L2 distance index (uncomment if needed)
-- CREATE INDEX idx_memory_embedding_l2
-- ON memory
-- USING ivfflat (embedding vector_l2_ops)
-- WITH (lists = 100);

-- Memory edges table for similarity relationships
CREATE TABLE memory_edge (
    source_id   INTEGER NOT NULL,
    target_id   INTEGER NOT NULL,
    weight      DOUBLE PRECISION NOT NULL CHECK (weight >= 0.0 AND weight <= 1.0),
    created_at  TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT pk_memory_edge PRIMARY KEY (source_id, target_id),
    CONSTRAINT fk_memory_edge_source
        FOREIGN KEY (source_id) REFERENCES memory (id) ON DELETE CASCADE,
    CONSTRAINT fk_memory_edge_target
        FOREIGN KEY (target_id) REFERENCES memory (id) ON DELETE CASCADE,
    CONSTRAINT chk_no_self_loops CHECK (source_id != target_id)
);

-- Indexes for memory_edge table
CREATE INDEX idx_memory_edge_source ON memory_edge (source_id);
CREATE INDEX idx_memory_edge_target ON memory_edge (target_id);
CREATE INDEX idx_memory_edge_weight ON memory_edge (weight DESC);

-- Composite index for finding edges by source and weight
CREATE INDEX idx_memory_edge_source_weight ON memory_edge (source_id, weight DESC);

-- Comments for documentation
COMMENT ON TABLE memory IS 'Stores text memories with vector embeddings for semantic search';
COMMENT ON TABLE memory_edge IS 'Stores similarity relationships between memories as a graph';
COMMENT ON COLUMN memory.embedding IS 'Vector embedding generated by OpenAI text-embedding-3-small (1536 dimensions)';
COMMENT ON COLUMN memory_edge.weight IS 'Similarity score between 0.0 and 1.0';

-- Optional: Create a view for easy querying of connected memories
CREATE OR REPLACE VIEW memory_connections AS
SELECT 
    m1.id AS source_id,
    m1.text AS source_text,
    m1.category AS source_category,
    m2.id AS target_id,
    m2.text AS target_text,
    m2.category AS target_category,
    me.weight AS similarity_score
FROM memory_edge me
JOIN memory m1 ON me.source_id = m1.id
JOIN memory m2 ON me.target_id = m2.id
ORDER BY me.weight DESC;

COMMENT ON VIEW memory_connections IS 'Convenient view showing memory connections with full text';
